### 后端编译与优化：

HotSpot中，解释执行和编译执行并存，两个搭配使用为混合模式

（解释执行：遇到一句翻译一句成机器码并执行

编译执行：先翻译成机器码，再一并执行）

HotSpot现有两/三个JIT：客户端C1编译器和服务端C2编译器（和Graal编译器）

因为即时编译会占据运行时间，为了在程序响应速度和运行效率之间达到最佳平衡，HotSpot引入**分层编译**.

##### 分层编译：

不同编译层次对代码的优化程度/优化所耗时间不同，实际执行中，解释器和C1和C2会同时工作，热点代码可能会被多次编译：可以先用C1编译器做优化程度不高但是耗时短的优化，给优化程度高但是耗时长的C2编译器争取时间，等编译完成之后就可以更改方法的调用入口地址，转而调用优化程度更高的代码。



“热点代码”有两类：

**被多次调用的方法** 和 **被多次执行的循环体**

不管是方法还是循环体，编译的目标对象都是一整个方法

循环体优化时，由于方法还在执行中，方法对应栈帧还在栈上，方法就被替换了，又叫“栈上替换OSR”

热点探测的方法有两种：

基于采样：周期性检查各线程栈顶，如果某个方法经常出现，认定为热点。（容易受线程阻塞等因素影响探测结果）

基于计数器：给方法建立计数器，当计数器的值达到一定阈值，认定热点

##### HotSpot使用了计数器方法：方法调用计数器 和 回边计数器

###### 方法调用计数器：

图394

默认情况下，执行引擎不会等待编译器执行完成，而是直接解释执行该方法，当编译器完成编译，改动方法调用入口，下一次调用就是用编译后的方法版本了

且方法调用计数器记录的并不是调用的绝对次数，而是一段时间内方法被调用的次数，相对频率。如果一定时间限度到了，方法计数器还没到阈值，将该方法计数器的值减少一半，称为热度衰减，这段时间叫半衰周期。

###### 回边计数器：空循环不算做回边

图395

记录的是循环的绝对次数，不会热度衰减。

如果发现超过阈值，提交OSR请求之后，会稍微降低回边计数器的值，继续以解释执行循环体

##### 即时编译过程：默认情况下，不管是方法热点还是循环体热点，在提交了编译请求，请求响应之前，jvm都会继续解释执行代码

对于C1编译器：分三个阶段

图397



#### 提前编译的两种实现 & 提前编译相对于即时编译的优缺点：

##### 1.在运行程序之前就把代码翻译为机器码：的确相对于即时编译可以避免占用运行时间，但是有些信息在运行之前很难获取到。

对于方法内联，静态编译的确可以不管时间长短，全局程序分析查看某个虚方法是否只会有单一版本、某些代码块是否不可能被调用到等等。这一部分不会像即时编译那样，影响到程序运行时间

但是一方面，因为静态编译后的结果在运行时不能有任何改动，导致静态编译相对于即时编译，优化策略要更保守。比如方法内联的时候，即时编译可以根据概率预测调用的方法版本，**激进优化**，如果预测出错，也可以退回到解释执行；而静态编译就不能这么做。

另一方面，方法内联，尤其是虚方法内联，静态编译更难实现（实际上可以做到）

##### 2.把即时编译的结果缓存下来，下次再运行到这些代码时直接使用缓存

针对目标机器，为应用程序提前编译：比如不同的Java程序起码会用到标准类库，可以对Java的标准类库提前编译，可以加快程序的启动速度。但是实际应用起来并不容易，这种方式不仅和目标机器相关，也和虚拟机参数相关：

比如在jvm的多种垃圾收集器中，有些垃圾收集器需要用到卡表，维护老年带到新生代的引用关系，从而减少youngGC时对老年代的扫描范围。而对卡表的维护，需要在更新对象引用的时候，生成内存屏障代码（写屏障/更新对象引用的AOP切面），这一块本来是和即时编译子系统配合的。提前编译自然也要完成这些

#### HotSpot中即时编译器的几种优化技术：

这些优化一定是基于代码的**中间表示**（字节码、HIR、LIR...）/机器码之上的，而不是直接的Java代码

- ##### 方法内联：是其他优化措施的基础，同时减少方法调用的成本（建立栈帧/查找方法版本。。）

Java遇到虚方法，并不是真的直接就去查虚方法表（速度较慢），而是先方法内联

<font color ="red">**只有invokespecial invokestatic调用的私有方法、父类方法、实例构造器方法、静态方法，以及invokedynamic调用的final方法可以在编译器进行解析。其他方法都需要在运行期根据接收者的实际类型选择方法版本（方法重载在编译期就可以完成选择）**</font>

###### 非虚方法的内联：不需要选择方法版本直接内联

###### 虚方法的内联：

1.CHA类型继承关系分析：向CHA查找当前这个方法是否有多个版本，如果只有一个版本，直接内联；如果的确有多个版本：第2步

2.内联缓存：这种状态下，方法调用是真的发生了的，但是还是比直接查虚方法表要更快

内联缓存位于虚方法入口前面，每次调用虚方法，都会先使用内联缓存，对比当前方法接收者和缓存里记录的接收者版本是否一致，如果是，后面开销相当于发生一次不内联的非虚方法调用；否则，缓存退化，开销就相当于真的去查虚方法表进行方法分派了

- ##### 逃逸分析

从不逃逸 ->方法逃逸（参数传递调用）-> 线程逃逸（全局实例变量）

逃逸分析可用于以下优化措施：

栈上分配：可支持方法逃逸，不支持线程逃逸（Java目前没得）

标量替换（可看作栈上分配的特例）：实例拆分，只创建其中的成员变量，可以把这些成员变量在栈上分配。不支持对象方法逃逸

同步消除：如果对象不逃出线程，就可以去掉对应的同步措施，锁消除

- ##### 公共子表达式消除

- ##### 数组边界检查消除

每次访问数组都需要检查一次有没有越界，消耗性能

可以在编译期检查这个访问是否越界（针对已经确定的访问索引位置）

或者隐式异常处理：先假设没问题，如果真的出了问题导致segment fault信号出现，就需要进程从用户态转内核态，更大消耗

#### Graal编译器：

JVMCI接口，和HotSpot虚拟机松耦合

字节码  ->  理想图  ->  理想图优化  ->  LIR  ->  机器码（LIR到机器码，这一步是由HotSpot虚拟机完成）





