### 线程安全单例模式&单例模式破解&spring容器单例&volatile禁止指令重排序

[线程安全单例模式&单例模式破解&spring容器单例](https://blog.csdn.net/qq_40111437/article/details/104770448)

上面这个链接，也提到了单例模式的线程安全问题，其中DCL单例模式的实例引用必须使用volatile修饰，否则如果JVM给构造函数进行指令重排序，就可能会造成：

某个线程内部对构造函数做了重排序，把本来应该在最后一步进行的 给引用赋值 这一步提到了前面，这个时候其实构造函数还没有完全执行完毕；如果此时另外一个线程拿到了这个还没有赋值完全的引用，就会出问题。

所以这里必须使用volatile修饰引用，禁止指令重排序。

<font color ="red">-->>构造函数是有可能线程不安全的，由于volatile的重排序，可能会造成线程安全问题，多线程环境下导致单例不再单例</font>

[为什么JVM会对代码做重排序？](https://blog.csdn.net/qq_35362055/article/details/78981792)提高指令运行的速度：

`现代CPU几乎都采用流水线机制加快指令的处理速度，一般来说，一条指令需要若干个CPU时钟周期处理，而通过流水线并行执行，可以在同等的时钟周期内执行若干条指令，具体做法简单地说就是把指令分为不同的执行周期，例如读取、寻址、解析、执行等步骤，并放在不同的元件中处理，同时在执行单元EU中，功能单元被分为不同的元件，例如加法元件、乘法元件、加载元件、存储元件等，可以进一步实现不同的计算并行执行。流水线架构决定了指令应该被并行执行，而不是在顺序化模型中所认为的那样。重排序有利于充分使用流水线，进而达到超标量的效果。`

`编译期重排序的典型就是通过调整指令顺序，在不改变程序语义的前提下，尽可能减少寄存器的读取、存储次数，充分复用寄存器的存储值。假设第一条指令计算一个值赋给变量A并存放在寄存器中，第二条指令与A无关但需要占用寄存器（假设它将占用A所在的那个寄存器），第三条指令使用A的值且与第二条指令无关。那么如果按照顺序一致性模型，A在第一条指令执行过后被放入寄存器，在第二条指令执行时A不再存在，第三条指令执行时A重新被读入寄存器，而这个过程中，A的值没有发生变化。通常编译器都会交换第二和第三条指令的位置，这样第一条指令结束时A存在于寄存器中，接下来可以直接从寄存器中读取A的值，降低了重复读取的开销。`

重排序不会破坏单线程下的语义一致；但是在多线程下就不一定了，可能会造成错误的执行结果 -->>JMM指定了happens-before规则，涉及用到了volatile synchronized等的代码，这些规则对重排序做一定限制

[链接](https://blog.csdn.net/qq_40111437/article/details/104946801)

