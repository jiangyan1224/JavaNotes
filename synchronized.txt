synchronize可以修饰方法/代码块
如果修饰的是静态方法，是对所有类对象起作用，只要调用这个方法，不管是不是通过同一个类对象调用这个方法，都会有互斥
如果修饰的是非静态方法：是对类对象起作用，多个线程同时调用同一个类对象的这个方法时，发生互斥
如果修饰的是代码块synchronized(Object){}：只有获取某一个对象锁，才能执行同步代码块

对修饰方法的时候：JVM使用ACC_SYNCHRONIZED标志，当线程访问方法时候，要看运行时常量池是不是又对应的ACC_SYNCHRONIZED标志，如果有，说明需要互斥，需要先获取对应的monitor锁，才能继续运行，退出方法的时候再释放锁、
修饰代码块的时候：使用monitorenter monitorexit，来获取和释放对应的monitor
---------------------
线程的阻塞 和唤醒必须转入内核态，用户态和内核态的切换会有很大的消耗，所以直接用synchronized的重量级锁是很消耗性能的

synchronized在使用重量级锁的时候，对象的mark word存储的是指向monitor的指针
monitor又叫管程，使用的是jvm里面使用c++实现的objectMonitor，Java中的wait notify notifyAll底层调用的都是ObjectMonitor的方法
管程其实是一种程序结构，封装了同步操作

管程弥补了 使用信号量产生的 PV操作分布在各个进程/线程中，导致不易控制管理，容易产生死锁的问题

里面主要有4个关键字：
count 记录了owner线程获取锁的次数，这也决定了synchronized是可重入锁
owner 指向当前拥有该对象的线程
waitSet 存储所有处于wait状态的线程队列
entryList 存储所有等待锁而被阻塞的队列
因为没拿到锁阻塞在synchronized那一行的都属于entryList；在同步代码块内部调用了wait方法的都进入waitSet队列

想获取monitor锁的线程先进入entryList等待
如果monitor的owner为空，就从entryList中取出一个作为owner执行同步代码块
当在同步代码块中执行了wait()，则该线程进入waitSet，并释放它持有的锁，owner设为null，这个时候entryList中的队列就可以获取锁了
当其他线程调用了notify()/notifyAll()，就会唤醒waitSet中一个或所有线程，这个线程会再次尝试获取monitor锁，如果成功，就会成为新的owner
当synchroinized关键字的作用范围结束，就会把monitor的owner设为null，退出

java对synchronized的优化：
偏向锁：把当前线程id写入到对象头，更新成功，则认为该线程获取了对象的偏向锁
轻量级锁：把对象头的mark word写到线程栈桢，并使用循环CAS尝试把对象的mark word改成指向栈帧的指针，如果更新成功，认为获取轻量级锁成功
自旋锁：如果线程执行同步代码块的时间短，暂时没拿到锁的可以先自旋一段时间，再尝试获取锁  -->自适应自旋锁
自适应自旋锁：根据线程上一次获取互斥锁的等待时间，【来决定这一次是否自旋和自旋次数】
锁粗化：在一段代码中频繁地对一个对象加锁解锁，会导致性能消耗，可以把锁范围扩大到这段代码之外，只进行一次加锁解锁
锁消除：锁消除发生在即时编译器运行的时候，如果发现在一段代码中所有堆中的数据都会逃逸出去被其他线程访问，则认为它们是线程私有的，不加锁

轻量级锁是在无竞争的情况下使用CAS代替互斥量，而偏向锁再无竞争的情况下把整个同步都消除掉，连CAS都没了

偏向锁的“偏”是偏向于第一个获得锁的线程，如果在接下来的过程中，没有其他线程获取锁，则第一个线程就不必再做同步操作
而轻量级锁适用于：互斥对象在被某个线程加锁 解锁的过程中，不会存在其他线程试图获取锁